# React 자습서 - tictacto
[repository](https://github.com/river994/tictacto)
* 밑줄 친 부분 정리

### 0. 개요 

> React 컴포넌트는 생성자에 this.state를 설정하는 것으로 state를 가질 수 있습니다. this.state는 정의된 React 컴포넌트에 대해 비공개로 간주해야 합니다.

> Javascript 클래스에서 하위 클래스의 생성자를 정의할 때 항상 super 를 호출해야 합니다. 모든 React 컴포넌트 클래스는 생성자를 가질 때 super(props) 호출 구문부터 작성해야 합니다.

### 1. 게임 완성하기

> (리팩토링과 안정성을 위해 요소 각각이 아닌) 부모 요소에 컴포넌트 상태를 저장하는 것이 가장 좋은 방법입니다. ... 여러개의 자식으로부터 데이터를 모으거나 두 개의 자식 컴포넌트들이 서로 통신하게 하려면 부모 컴포넌트에 공유 state를 정의해야 합니다.

> 부모 컴포넌트는 props를 사용하여 자식 컴포넌트에 state를 다시 전달할 수 있습니다. 이것은 자식 컴포넌트들이 서로 또는 부모 컴포넌트와 동기화 하도록 만듭니다.

> React에서 이벤트를 나타내는 prop에는 on[Event], 이벤트를 처리하는 함수에는 handle[Event]를 사용하는 것이 일반적입니다.

> 자식 컴포넌트가 더 이상 state를 유지하지 않기 때문에 자식 컴포넌트에서 값을 받아 클릭될 때 부모 컴포넌트에 정보를 전달합니다. React 용어로 자식 컴포넌트는 이제 제어되는 컴포넌트입니다.

#### 1.1 불변성이 왜 중요할까요?
  - 데이터 변경 1. 값을 직접 변경 / 2. 원하는 변경 값을 가진 새로운 사본으로 데이터 교체
  - 2번 방법의 이점
    + 불변성은 복잡한 특징들을 단순하게 만듬
      - 직접적인 데이터 변이를 피함 -> 게임이력 유지, 나중에 재사용 가능
    + 변화를 감지함
    + React에서 다시 렌더링하는 시기를 결정함
      - 데이React에서 순수 컴포넌트를 만드는 데 도움

### 2. 시간 여행 추가하기
  > 배열 push() 함수와 같이 더 익숙한 방식과 달리 concat() 함수는 기존 배열을 복제하지 않기 때문에 이를 더 권장

#### 2.1 Key 선택하기
  - 배열이나 이터레이터의 자식들은 고유의 'key' prop 가지고 있어야 함
  - Key는 심화 기능인 ref와 동일하게 특별하고 미리 지정된 prop으로 컴포넌트는 key를 조회할 수 없음
  - 동적인 리스트를 만들때마다 적절한 키 할당
  - 키 지정되지 않은 경우 배열의 인덱스를 기본키로 사용
  - 키 전역 고유 X, 컴포넌트와 관련 아이템 사이에서 고유한 값 O